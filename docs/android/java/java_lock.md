### 锁的分类
#### 乐观锁vs悲观锁
乐观锁：不加锁更新数据时会判断是否被修改，如被修改会发送自旋，java.util.concurret.atomic包下的原子变量类，基于CAS实现

悲观锁：获取数据时都会上锁，synchronized

#### 独享锁vs共享锁
独享锁：锁只能被一个线程所持有，ReentrantLock

共享锁：锁能被多个线程所持有，ReadWriteLock中读锁是共享锁，写锁是独享锁

#### 互斥锁vs读写锁
广义说法

互斥锁：具体实现ReentrantLock

读写锁：具体实现ReadWriteLock

#### 可重入锁
```java
synchronized void A(){}
synchronized void B(){}
```
此处锁的是对象，即对于同一个对象不能同时调用A、B方法，如果不可重入，A方法获得锁后还没释放锁之前，B也能获得锁，导致死锁

#### <a id="fairUnfair">公平锁和非公平锁</a>
|   | 公平锁  | 非公平锁  |
|  ----  | ----  | ----  |
| 定义  | 多个线程排队申请锁 | 多个线程都尝试获得锁，先占先得 |
| 优点  | 所有线程都能获得锁 | 减少cpu唤醒开销，吞吐效率变高 |
| 缺点  | 除了第一个线程，后续线程会阻塞导致增加cpu唤醒开销变大，吞吐效率变低 | 有可能导致某些线程一直无法获得锁 |

ReentrantLock默认是非公平锁，ReentrantLock(true)为公平锁，分别对应NonfairSync和FairSync

#### 分段锁
是一种设计，ConcurrentHashMap分段锁封装为Segment

#### 偏向锁/轻量级锁/重量级锁
指锁的状态，偏向锁指一段同步代码一直被一个线程访问

轻量级锁：偏向锁被另一个线程访问后升级，其他线程通过自旋尝试获取锁，不会阻塞

重量级锁：轻量级锁时，另一个线程自旋一定次数后无法获得锁就进入阻塞

#### 自旋锁
尝试获取锁的线程不会立即阻塞，采取循环的方式获取锁，减少线程上下文切换的消耗，缺点是消耗cpu

