### 锁的分类
#### 乐观锁vs悲观锁
乐观锁：不加锁更新数据时会判断是否被修改，如被修改会发送自旋(可理解为死循环)，java.util.concurret.atomic包下的原子变量类，基于CAS实现

悲观锁：获取数据时都会上锁，synchronized

一般乐观锁性能比悲观锁好，原因是：上下文切换需要3-5ms，cpu执行指令约0.6ns，拿锁至少需要2次上下文切换

#### 独享锁vs共享锁
独享锁：锁只能被一个线程所持有，ReentrantLock

共享锁：锁能被多个线程所持有，ReadWriteLock中读锁是共享锁，写锁是独享锁

#### 互斥锁vs读写锁
广义说法

互斥锁：具体实现ReentrantLock

读写锁：具体实现ReadWriteLock

#### 可重入锁
```java
synchronized void A(){}
synchronized void B(){}
```
此处锁的是对象，即对于同一个对象不能同时调用A、B方法，如果不可重入，A方法获得锁后还没释放锁之前，B也能获得锁，导致死锁

#### <a id="fairUnfair">公平锁和非公平锁</a>
|   | 公平锁  | 非公平锁  |
|  ----  | ----  | ----  |
| 定义  | 多个线程排队申请锁 | 多个线程都尝试获得锁，先占先得 |
| 优点  | 所有线程都能获得锁 | 减少cpu唤醒开销，吞吐效率变高 |
| 缺点  | 除了第一个线程，后续线程会阻塞导致增加cpu唤醒开销变大，吞吐效率变低 | 有可能导致某些线程一直无法获得锁 |

ReentrantLock默认是非公平锁，ReentrantLock(true)为公平锁，分别对应NonfairSync和FairSync

#### 分段锁
是一种设计，ConcurrentHashMap分段锁封装为Segment

#### 偏向锁/轻量级锁/重量级锁
指锁的状态，偏向锁指一段同步代码一直被一个线程访问

轻量级锁：偏向锁被另一个线程访问后升级，其他线程通过自旋尝试获取锁，不会阻塞

重量级锁：轻量级锁时，另一个线程自旋一定次数后无法获得锁就进入阻塞

#### 自旋锁
尝试获取锁的线程不会立即阻塞，采取循环的方式获取锁，减少线程上下文切换的消耗，缺点是消耗cpu

### sleep和wait的区别
Thread.Sleep(0)的作⽤，触发操作系统⽴刻重新进⾏⼀次CPU竞争

1、sleep是Thread的静态⽅法，wait是Object的⽅法，任何对象实例都能调⽤。

2、sleep不会释放锁。wait会释放锁，但调⽤它的前提是当前线程占有锁(即代码要在synchronized中)。

3、它们都可以被interrupt⽅法中断

4、notify是需要等synchronized包裹的所有代码执行完成才释放锁

|   | sleep  | wait  |
|  ----  | ----  | ----  |
| 同步  | 无限制 | synchronized中使用 |
| 作用对象  | 定义在Thread中，作用域当前线程 | 定义在Object中，作用于本身 |
| 释放锁  | 否 | 是 |
| 唤醒条件  | 超时或调用interrupt方法 | 其他线程调用notify或notifyAll |
| 方法属性  | 静态方法 | 实例⽅法 |

### 死锁
1. 互斥条件，每个资源每次只能被一个线程（或进程，下同）使用
2. 请求与保持条件，当一个线程试图获取资源，但发生了阻塞，则需对已获得的资源保持不放
3. 不剥夺条件，指线程已获得的资源，在未使用完之前，不会被强行剥夺
4. 循环等待条件，多个线程之间必须形成“循环等待”，才有可能形成死锁

总结：

1. 多个操作者(m>=2)，争夺多个资源(n>=2)，且n<=m
2. 争夺资源的顺序不对
3. 拿到资源不放手

防止死锁：从2和3解决，不使用互斥锁，lock锁超时机制释放锁，资源标记有序去锁资源，银行家算法

### AQS
AbstractqueuedSynchronizer