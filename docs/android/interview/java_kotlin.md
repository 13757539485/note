### 抽象类与接口的区别
||定义|实现|成员特性|构造器|
|--|--|--|--|--|
|​抽象类|使用abstract关键字|一个类只能继承一个抽象类，使用extends关键字|包含常量、变量、抽象方法和非抽象方法,抽象方法必须在子类中被实现，非抽象方法可以提供默认实现|可以有构造器，但不能实例化
|​接口|使用interface关键字|一个类可以实现多个接口，使用implements关键字|只能包含常量和抽象方法,Java8开始，接口可以包含默认方法(default关键字)和静态方法|不能有构造器

### 类和对象的区别，生命周期

​定义：

​类：类是对一组具有相同属性和行为的对象的抽象描述，是创建对象的模板。类定义了对象的属性（成员变量）和行为（成员函数）

​对象：对象是类的具体实例，是根据类的定义创建的实体。每个对象都有自己独立的属性和状态

​关系：

类是对象的抽象，对象是类的具体实现。一个类可以有多个对象实例，每个对象都拥有类中定义的属性和方法，但其具体的状态可能不同

​使用：

类不能直接使用，必须通过创建对象来使用。对象可以直接使用，通过对象可以访问和操作类的属性和方法

类的生命周期

- ​加载：将类的二进制流加载到内存中，并生成对应的Class对象
- ​验证：确保加载的类文件格式正确，符合JVM规范
- ​准备：为类的静态变量分配内存，并赋予初始值
- ​解析：将符号引用转换为直接引用
- ​初始化：调用类的构造器方法，对静态变量进行赋值，并执行静态初始化块
- ​使用：类被加载后，可以被程序使用，直到程序结束
- ​卸载：类加载器被回收时，类才会被卸载

对象的生命周期

- 创建（Created）​：使用 new 关键字创建对象，分配内存空间，并调用构造函数进行初始化。
- ​应用（InUse）​：对象至少被一个强引用持有，处于可访问状态，程序正在使用该对象。
- ​不可见（Invisible）​：对象不再被程序的任何强引用持有，但由于某些特殊情况（如静态变量、线程或 JNI 引用）仍然存在。
- ​不可达（Unreachable）​：对象不再被任何强引用持有，且没有任何 GC Root 引用它，此时对象可以被垃圾回收器回收。
- ​收集（Collected）​：垃圾回收器准备回收对象占用的内存空间，如果对象重写了 finalize() 方法，此时会执行该方法。
- ​终结（Finalized）​：对象等待垃圾回收器完成回收过程。
- ​对象空间重新分配（Deallocated）​：垃圾回收器回收对象占用的内存空间，并将其重新分配给其他对象

### 什么是GC Root，常见有哪些
指的是垃圾回收过程中作为根节点的对象。这些对象是 GC 算法开始遍历以确定哪些对象是“可达的”起点

常见：

- 虚拟机栈（Java Stack）中的局部变量引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈（Native Method Stack）中 JNI（Java Native Interface）引用的对象。
- 被激活的 Java 线程。
- 被系统类加载器加载的类等

### Java成员变量，局部变量和静态变量区别

定义

- ​成员变量：定义在类中，但在方法、构造函数或代码块之外的变量。成员变量可以是实例变量或静态变量。
- ​局部变量：定义在方法、构造函数或代码块内部的变量。局部变量不能被访问修饰符（如public、private）修饰，也不能被static修饰。
- ​静态变量：使用static关键字修饰的成员变量，属于类本身，而不是类的实例。静态变量在类加载时初始化，且只有一份副本。

存储

- ​成员变量：如果未使用static修饰，存储在堆内存中，与对象实例一起分配空间；如果使用static修饰，存储在方法区（或称为静态存储区）。
- ​局部变量：存储在栈内存中，随着方法的调用而创建，方法执行结束后被销毁。
- ​静态变量：存储在方法区，所有实例共享同一份静态变量。

生命周期

- ​成员变量：实例变量的生命周期与对象的生命周期一致，对象被创建时创建，对象被销毁时销毁；静态变量的生命周期与类的生命周期一致，类加载时创建，类卸载时销毁。
- ​局部变量：生命周期仅限于方法、构造函数或代码块的执行期间，方法执行结束后自动销毁。
- ​静态变量：生命周期从类加载开始，到类卸载结束。

作用域

- ​成员变量：作用域是整个类，可以在类的任何方法中访问。
- ​局部变量：作用域仅限于定义它的方法、构造函数或代码块内部。
- ​静态变量：作用域是整个类，可以通过类名直接访问，也可以通过对象访问。
默认值

- ​成员变量：如果未显式初始化，实例变量会有默认值（如int为0，boolean为false，引用类型为null）；静态变量同样有默认值。
- ​局部变量：没有默认值，必须显式初始化后才能使用。
- ​静态变量：如果未显式初始化，会有默认值。

访问修饰符

- ​成员变量：可以被public、private、protected或默认访问修饰符修饰。
- ​局部变量：不能被访问修饰符修饰。
- ​静态变量：可以被public、private、protected或默认访问修饰符修饰。

### 内部类有哪些，java和kotlin内部类的区别

- 成员内部类: 定义在另一个类的内部，但不在方法内部。
可以访问外部类的所有成员（包括私有成员）。创建实例时需要外部类的实例：外部类名.内部类名 变量名 = 外部类实例.new 内部类名();

- ​静态内部类（Static Nested Class）​：使用static关键字修饰的内部类。不依赖于外部类的实例，可以直接通过外部类名访问。只能访问外部类的静态成员，不能访问非静态成员。创建实例时不需要外部类的实例：外部类名.内部类名 变量名 = new 外部类名.内部类名();

- ​局部内部类​：定义在方法内部的类。只能在该方法内部使用，对外部不可见。可以访问外部类的所有成员，但只能访问方法中的final或effectively final局部变量。创建实例时直接在方法内部：内部类名 变量名 = new 内部类名();

- ​匿名内部类​：没有名字的内部类，通常用于创建实现某个接口或继承某个类的对象。适用于一次性使用的场景，如事件处理。定义和实例化同时进行，通常在创建对象时直接实现接口或继承类

kotlin中默认的内部类是java中的静态内部类，使用inner修饰class后才是java中的成员内部类

### 反射机制原理和应用场景

反射的实现依赖于虚拟机（如 JVM）提供的底层支持。

​元数据存储：在编译时，编译器会将类的元数据（如方法、字段、构造函数等）写入到字节码文件（如 .class 文件）中。JVM 在加载类时，会解析这些元数据并存储在内存中，供反射机制使用。

​反射 API 的实现：Java 的反射 API（如 java.lang.reflect 包中的类）是对 JVM 提供的底层接口的封装。这些底层接口允许 Java 程序访问和操作 JVM 内部存储的类元数据。
例如，Class 类提供了访问类元数据的方法，这些方法实际上是通过 JVM 的内部机制实现的。

aosp对反射的限制

​Dex-level限制：从Android 9.0（Pie）开始，AOSP在编译时会对被@hide注解的方法进行标记，并在运行时阻止对这些方法的反射访问。这些标记使得系统能够在运行时识别并限制对隐藏API的访问。

​Hidden API Enforcement：Android 9.0引入了隐藏API执行策略，将隐藏API分为灰名单、黑名单等类别。对于黑名单中的API，系统会直接抛出异常（如NoSuchMethodError），阻止应用通过反射访问这些方法。

​权限控制和签名机制：某些隐藏API需要特定的权限或系统签名才能访问。只有系统应用或具有系统签名的应用才能通过反射调用这些受保护的方法。

​运行时检查：系统在运行时会检查调用栈的可信度，只有来自可信来源（如系统类）的调用才会被允许。这防止了恶意应用通过反射等方式绕过限制

基于反射常见三方库：Shadow、ARouter、Retrofit、EventBus、Gson、FastJson、Moshi等

### 讲讲final，static，synchronized关键字
final: 表示“最终的”或“不可改变的”,可以修饰类、方法和变量

修饰类：此类不可被继承，如String类。kotlin中默认不能被继承需使用open/abstract关键字

修饰方法：此方法不可被重写。kotlin中默认不能被重写需使用open关键字

修饰变量：此变量只能被赋值一次，不可被重新赋值。kotlin中使用val代替，区别是声明时val必须赋值，final可以先声明再构造方法中赋值或声明时赋值

static：表示“静态的”或“属于类的”，可以修饰变量、方法、代码块和嵌套类

常量：final static,在kotlin中使用const val(只能在object或者companion object或者类外使用)

synchronized：用于实现线程同步，确保多个线程对共享资源的访问是安全的

同步方法：方法在同一时刻只能被一个线程访问

同步代码块：代码块在同一时刻只能被一个线程访问

静态同步方法：静态方法锁定的是类的Class对象，确保同一时刻只有一个线程可以执行该类的静态同步方法

kotlin中同步方法只能使用@Synchronized

### 请简述一下String、StringBuffer和StringBuilder

||可变性|​线程安全|​性能|​适用场景|
|--|--|--|--|--|
|String|不可变的，每次创建新的String对象，原对象被丢弃|线程安全|性能较低|字符串内容不经常变化|
|StringBuffer|可变的,原有对象上进行修改|线程安全|由于同步机制，性能略低于StringBuilder|多线程环境下频繁修改字符串|
|StringBuilder|可变的|方法没有同步机制,线程不安全|性能最高|单线程环境下频繁修改字符串

### “equals”与“==”、“hashCode”的区别和使用场景

基本数据类型不能使用equals，==是比较值是否相等

默认情况下，引用类型使用equals和==效果相同，比较的是对象的内存地址

hashCode和equals作用类似，用来对比两个对象内容是否相等

- hashcode 相等，equals不一定相等
- equals 相等，hashcode一定相等
- hashcode 不相等，equals一定不相等

hashCode默认是基于对象内存地址，相等情况为哈希冲突时和内存地址重用时

重写hashCode是为了在HashMap,HashSet等基于哈希表实现的集合比较对象时可能误判

### Java中深拷贝与浅拷贝的区别
见[拷贝](../kotlin/kotlin_class.md#kotlin_copy)

### 谈谈Error和Exception的区别

Error和Exception都是Throwable类的子类，都可以被抛出(throw)和捕获(try catch)

Exception：表示程序运行中可以被预料到的异常情况，应该被捕获并进行相应的处理，分为两类

编译时异常：编译器强制要求处理，例如IOException，必须通过try-catch或throws声明

运行时异常：编译器不强制处理，通常由代码逻辑错误导致，例如NullPointerException

​Error：表示系统级的不可恢复错误，通常是JVM或系统资源引发的严重问题，程序无法通过代码进行处理或恢复。例如OutOfMemoryError、StackOverflowError，不应该被捕获或处理

### 谈谈你对Java泛型中类型擦除的理解，并说说其局限性

泛型类型参数（如 <T>）会被替换为边界类型（默认为 Object，或用户指定的上限类型，如 <T extends Number> 替换为 Number）。例如，List<String> 和 List<Integer> 在编译后都会变成 List，其 Class 对象相同（ArrayList.class）。

Java 1.5 引入泛型时，需要保证旧版本非泛型代码仍能运行，避免修改 JVM 底层机制

局限性

- 运行时类型信息丢失
- 无法创建泛型数组
- 无法实现基于泛型的重载
- 不安全，通过反射可以绕过泛型限制，向 List<Integer> 插入 String 对象

[泛型基本知识](../java/java_genericity.md)

### String为什么要设计成不可变的
安全性：由于字符串在程序中经常用于存储敏感信息（如数据库连接字符串、密码等），不可变性确保了这些信息在传递过程中不会被意外修改，从而提高了安全性。

​线程安全：不可变的字符串可以在多个线程之间安全地共享，而不需要额外的同步机制。这简化了并发编程，避免了数据竞争和不一致的问题。

​性能优化：不可变的字符串可以被缓存和重用。Java中的字符串池（String Pool）机制就是基于这一点，多个相同的字符串字面量可以共享同一个对象，从而节省内存空间。此外，不可变性还使得字符串的哈希值可以被缓存，提高了哈希表的查找效率。

​哈希表的使用：由于字符串是不可变的，它们可以作为字典的键（keys）或集合（sets）的元素。如果字符串是可变的，那么它们的哈希值可能会随着内容的改变而改变，导致无法正确地在哈希表中查找和比较。

​简化设计和实现：不可变性使得字符串的设计和实现更加简单和一致。开发人员不需要考虑字符串在多个地方被修改的情况，从而减少了潜在的错误

### 说说你对Java注解的理解

见[注解使用](../java/java_annotation.md)

### 谈谈List,Set,Map的区别

List：有序的集合，允许重复元素，主要实现类​ArrayList和​LinkedList

Set：不保证顺序(LinkedHashSet和TreeSet除外)，不允许重复元素，主要实现类​HashSet、LinkedHashSet和TreeSet

Map：键值对，key不允许重复，value允许重复，不保证顺序(LinkedHashMap和TreeMap除外)，主要实现类HashMap、LinkedHashMap和TreeMap

### 各个集合的时间复杂度

|特性|ArrayList|LinkedList|HashSet|LinkedHashSet|TreeSet|HashMap|LinkedHashMap|TreeMap|
|--|--|--|--|--|--|--|--|--|
|​插入|O(1)|O(1)|O(1)|O(1)|O(log n)|O(1)|O(1)|O(log n)|
|​删除|O(n)|O(1)|O(1)|O(1)|O(log n)|O(1)|O(1)|O(log n)|
|​查找|O(1)|O(n)|O(1)|O(1)|O(log n)|O(1)|O(1)|O(log n)|
|​访问元素|O(1)|O(n)|不支持|不支持|不支持|不支持|不支持|不支持|
|​有序性|插入顺序|插入顺序|无序|插入顺序|自然顺序或自定义|无序|插入顺序|然顺序或自定义|

### 谈谈ArrayList和LinkedList的区别

​ArrayList：

- 基于动态数组实现，支持快速随机访问。
- 插入和删除操作在列表中间位置时效率较低。

​LinkedList：

- 基于双向链表实现，插入和删除操作效率高。
- 随机访问效率较低。

### 请说一下HashMap与HashTable的区别

HashMap：非线程安全，key/value允许null值，初始容量为16，每次扩容为2倍

​HashTable：线程安全(synchronized)，不允许null值，初始容量为11，每次扩容为原来的2n+1

### 谈一谈ArrayList的扩容机制

见[ArrayList](../java/java_collection.md#arraylist)

### HashMap的实现原理

见[HashMap](../java/java_collection.md#hashmap)

哈希表指的是

- ​哈希桶数组（Node<K,V>[] table）​：这是存储键值对的核心数组，每个元素是一个链表的头节点
- ​节点类（Node<K,V>）​：用于表示哈希表中的每个键值对，包含键、值、哈希码和指向下一个节点的引用
- ​哈希函数（hash方法）​：用于计算键的哈希值，并将其映射到数组的索引位置

### 请简述LinkedHashMap的工作原理和使用方式

和HashMap类似不是线程安全的,除了哈希表维护了一个双向链表,LRU（最近最少使用）缓存，通过重写removeEldestEntry，见[LinkedHashMap](../java/java_collection.md#linkedhashmap)

使用方式和HashMap相同

### 谈谈对于ConcurrentHashMap的理解

高性能、线程安全的哈希表实现，相比HashTable和Collections.synchronizedMap()，ConcurrentHashMap提供了更高的并发性能，允许多个线程同时读取和写入数据，而不会导致数据不一致或性能瓶颈

​JDK 1.7：使用分段锁（Segment）机制，将数据分成多个段，每个段独立加锁，从而提高并发度。

​JDK 1.8：移除了分段锁，采用 CAS + synchronized机制，直接使用Node<K,V>[] table结构，简化了数据结构并提高了性能

扩容机制和HashMap相同，区别是HashMap扩容是单线程，它是多线程，并发扩容性能影响更少

### Java中使用多线程的方式有哪些

[启动线程的方式](../java/java_thread.md#thread_start)

### 说一下线程的几种状态

[线程状态](../java/java_thread.md#thread_life)

### 如何实现多线程中的同步
1. ​使用synchronized关键字
2. 使用ReentrantLock类
3. 使用volatile关键字
4. 使用原子类，如AtomicInteger、AtomicLong等
5. 使用Semaphore类
6. 使用CountDownLatch和CyclicBarrier

### 谈谈线程死锁，如何有效的避免线程死锁

指两个或多个线程在运行过程中，因争夺资源而造成的一种互相等待的现象

- ​固定加锁顺序：确保所有线程以相同的顺序获取锁，打破循环等待条件。
- ​使用超时机制：在获取锁时设置超时时间，超过时间后放弃获取锁并释放已持有的锁。
- ​避免嵌套锁：尽量避免在一个线程中同时获取多个锁，如果必须获取多个锁，确保按照固定的顺序获取。
- ​使用死锁检测工具：利用工具如 JProfiler、VisualVM 等检测和解决死锁问题。
- ​减少共享资源：尽量减少进程间共享资源的数量，或者采用副本而不是共享资源的方式

### 谈谈线程阻塞的原因

线程阻塞是指线程在运行过程中由于某些条件未满足而暂停执行的状态

原因

1. ​等待I/O操作：线程进行输入/输出操作（如读写文件、网络通信）时，如果操作不能立即完成，线程会被阻塞，直到I/O操作完成或发生错误。
2. ​同步等待：线程在访问共享资源（如同步代码块或方法）时，如果无法获得所需的锁，线程会被阻塞，直到获取到锁才能继续执行。
3. 睡眠等待：线程调用Thread.sleep(int n)方法后，会进入睡眠状态，暂停执行指定的时间，时间结束后线程恢复运行。
4. ​等待信号：线程调用对象的wait()方法后，会进入等待状态，直到其他线程调用该对象的notify()或notifyAll()方法将其唤醒。
5. ​等待连接：在网络编程中，线程在尝试与服务器建立连接（如调用Socket.connect()）时，如果连接未成功，线程会被阻塞，直到连接建立或发生异常。
6. ​读取数据：线程从输入流（如Socket的输入流）读取数据时，如果没有足够的数据，线程会被阻塞，直到读取到足够的数据或发生异常。
7. ​写入数据：线程向输出流（如Socket的输出流）写入数据时，如果输出缓冲区已满，线程会被阻塞，直到数据被完全写入或发生异常。
8. ​关闭连接：线程在关闭套接字（如调用Socket.close()）时，如果设置了延迟关闭，线程会被阻塞，直到所有数据发送完毕或超过延迟时间

### 请谈谈Thread中run()与start()的区别

run方法：不会创建线程，只是一个普通方法，可以被多次调用

start方法：jvm会创建线程，只能调用一次

### synchronized和volatile关键字的区别

见[synchronized vs volatile](../java/java_safe.md#synchronized_volatile)

### java线程中notify和notifyAll有什么区别
notify()：唤醒在此对象监视器上等待的单个线程。

如果有多个线程在对象监视器上等待，notify() 方法会随机一个线程唤醒，被唤醒的线程需要重新获取对象的锁，才能继续执行。

notifyAll()：唤醒在此对象监视器上等待的所有线程。
所有线程被唤醒后，它们都需要重新获取对象的锁，然后才能继续执行。
在竞争锁的过程中，只有一个线程能够获得锁并继续执行，其他线程将再次进入等待状态

### 什么是线程池？如何创建一个线程池？

见[线程池](../java/java_safe.md#thread_pool)

### 谈一谈java线程常见的几种锁？

[锁的分类](../java/java_lock.md#java_lock)

### 谈一谈线程sleep()和wait()的区别？

[sleep vs wait](../java/java_lock.md#sleep_wait)

### 谈谈ThreadLocal用法和原理
[ThreadLocal](../java/java_base.md#threadlocal)
