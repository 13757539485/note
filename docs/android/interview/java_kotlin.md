### 抽象类与接口的区别
||定义|实现|成员特性|构造器|
|--|--|--|--|--|
|​抽象类|使用abstract关键字|一个类只能继承一个抽象类，使用extends关键字|包含常量、变量、抽象方法和非抽象方法,抽象方法必须在子类中被实现，非抽象方法可以提供默认实现|可以有构造器，但不能实例化
|​接口|使用interface关键字|一个类可以实现多个接口，使用implements关键字|只能包含常量和抽象方法,Java8开始，接口可以包含默认方法(default关键字)和静态方法|不能有构造器

### 类和对象的区别，生命周期

​定义：

​类：类是对一组具有相同属性和行为的对象的抽象描述，是创建对象的模板。类定义了对象的属性（成员变量）和行为（成员函数）

​对象：对象是类的具体实例，是根据类的定义创建的实体。每个对象都有自己独立的属性和状态

​关系：

类是对象的抽象，对象是类的具体实现。一个类可以有多个对象实例，每个对象都拥有类中定义的属性和方法，但其具体的状态可能不同

​使用：

类不能直接使用，必须通过创建对象来使用。对象可以直接使用，通过对象可以访问和操作类的属性和方法

类的生命周期

- ​加载：将类的二进制流加载到内存中，并生成对应的Class对象
- ​验证：确保加载的类文件格式正确，符合JVM规范
- ​准备：为类的静态变量分配内存，并赋予初始值
- ​解析：将符号引用转换为直接引用
- ​初始化：调用类的构造器方法，对静态变量进行赋值，并执行静态初始化块
- ​使用：类被加载后，可以被程序使用，直到程序结束
- ​卸载：类加载器被回收时，类才会被卸载

对象的生命周期

- 创建（Created）​：使用 new 关键字创建对象，分配内存空间，并调用构造函数进行初始化。
- ​应用（InUse）​：对象至少被一个强引用持有，处于可访问状态，程序正在使用该对象。
- ​不可见（Invisible）​：对象不再被程序的任何强引用持有，但由于某些特殊情况（如静态变量、线程或 JNI 引用）仍然存在。
- ​不可达（Unreachable）​：对象不再被任何强引用持有，且没有任何 GC Root 引用它，此时对象可以被垃圾回收器回收。
- ​收集（Collected）​：垃圾回收器准备回收对象占用的内存空间，如果对象重写了 finalize() 方法，此时会执行该方法。
- ​终结（Finalized）​：对象等待垃圾回收器完成回收过程。
- ​对象空间重新分配（Deallocated）​：垃圾回收器回收对象占用的内存空间，并将其重新分配给其他对象

### 什么是GC Root，常见有哪些
指的是垃圾回收过程中作为根节点的对象。这些对象是 GC 算法开始遍历以确定哪些对象是“可达的”起点

常见：

- 虚拟机栈（Java Stack）中的局部变量引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈（Native Method Stack）中 JNI（Java Native Interface）引用的对象。
- 被激活的 Java 线程。
- 被系统类加载器加载的类等

### Java成员变量，局部变量和静态变量区别

定义

- ​成员变量：定义在类中，但在方法、构造函数或代码块之外的变量。成员变量可以是实例变量或静态变量。
- ​局部变量：定义在方法、构造函数或代码块内部的变量。局部变量不能被访问修饰符（如public、private）修饰，也不能被static修饰。
- ​静态变量：使用static关键字修饰的成员变量，属于类本身，而不是类的实例。静态变量在类加载时初始化，且只有一份副本。

存储

- ​成员变量：如果未使用static修饰，存储在堆内存中，与对象实例一起分配空间；如果使用static修饰，存储在方法区（或称为静态存储区）。
- ​局部变量：存储在栈内存中，随着方法的调用而创建，方法执行结束后被销毁。
- ​静态变量：存储在方法区，所有实例共享同一份静态变量。

生命周期

- ​成员变量：实例变量的生命周期与对象的生命周期一致，对象被创建时创建，对象被销毁时销毁；静态变量的生命周期与类的生命周期一致，类加载时创建，类卸载时销毁。
- ​局部变量：生命周期仅限于方法、构造函数或代码块的执行期间，方法执行结束后自动销毁。
- ​静态变量：生命周期从类加载开始，到类卸载结束。

作用域

- ​成员变量：作用域是整个类，可以在类的任何方法中访问。
- ​局部变量：作用域仅限于定义它的方法、构造函数或代码块内部。
- ​静态变量：作用域是整个类，可以通过类名直接访问，也可以通过对象访问。
默认值

- ​成员变量：如果未显式初始化，实例变量会有默认值（如int为0，boolean为false，引用类型为null）；静态变量同样有默认值。
- ​局部变量：没有默认值，必须显式初始化后才能使用。
- ​静态变量：如果未显式初始化，会有默认值。

访问修饰符

- ​成员变量：可以被public、private、protected或默认访问修饰符修饰。
- ​局部变量：不能被访问修饰符修饰。
- ​静态变量：可以被public、private、protected或默认访问修饰符修饰。

### 内部类有哪些，java和kotlin内部类的区别

- 成员内部类: 定义在另一个类的内部，但不在方法内部。
可以访问外部类的所有成员（包括私有成员）。创建实例时需要外部类的实例：外部类名.内部类名 变量名 = 外部类实例.new 内部类名();

- ​静态内部类（Static Nested Class）​：使用static关键字修饰的内部类。不依赖于外部类的实例，可以直接通过外部类名访问。只能访问外部类的静态成员，不能访问非静态成员。创建实例时不需要外部类的实例：外部类名.内部类名 变量名 = new 外部类名.内部类名();

- ​局部内部类​：定义在方法内部的类。只能在该方法内部使用，对外部不可见。可以访问外部类的所有成员，但只能访问方法中的final或effectively final局部变量。创建实例时直接在方法内部：内部类名 变量名 = new 内部类名();

- ​匿名内部类​：没有名字的内部类，通常用于创建实现某个接口或继承某个类的对象。适用于一次性使用的场景，如事件处理。定义和实例化同时进行，通常在创建对象时直接实现接口或继承类

kotlin中默认的内部类是java中的静态内部类，使用inner修饰class后才是java中的成员内部类

### 反射机制原理和应用场景

反射的实现依赖于虚拟机（如 JVM）提供的底层支持。

​元数据存储：在编译时，编译器会将类的元数据（如方法、字段、构造函数等）写入到字节码文件（如 .class 文件）中。JVM 在加载类时，会解析这些元数据并存储在内存中，供反射机制使用。

​反射 API 的实现：Java 的反射 API（如 java.lang.reflect 包中的类）是对 JVM 提供的底层接口的封装。这些底层接口允许 Java 程序访问和操作 JVM 内部存储的类元数据。
例如，Class 类提供了访问类元数据的方法，这些方法实际上是通过 JVM 的内部机制实现的。

aosp对反射的限制

​Dex-level限制：从Android 9.0（Pie）开始，AOSP在编译时会对被@hide注解的方法进行标记，并在运行时阻止对这些方法的反射访问。这些标记使得系统能够在运行时识别并限制对隐藏API的访问。

​Hidden API Enforcement：Android 9.0引入了隐藏API执行策略，将隐藏API分为灰名单、黑名单等类别。对于黑名单中的API，系统会直接抛出异常（如NoSuchMethodError），阻止应用通过反射访问这些方法。

​权限控制和签名机制：某些隐藏API需要特定的权限或系统签名才能访问。只有系统应用或具有系统签名的应用才能通过反射调用这些受保护的方法。

​运行时检查：系统在运行时会检查调用栈的可信度，只有来自可信来源（如系统类）的调用才会被允许。这防止了恶意应用通过反射等方式绕过限制

基于反射常见三方库：Shadow、ARouter、Retrofit、EventBus、Gson、FastJson、Moshi等

### 讲讲final，static，synchronized关键字
final: 表示“最终的”或“不可改变的”,可以修饰类、方法和变量

修饰类：此类不可被继承，如String类。kotlin中默认不能被继承需使用open/abstract关键字

修饰方法：此方法不可被重写。kotlin中默认不能被重写需使用open关键字

修饰变量：此变量只能被赋值一次，不可被重新赋值。kotlin中使用val代替，区别是声明时val必须赋值，final可以先声明再构造方法中赋值或声明时赋值

static：表示“静态的”或“属于类的”，可以修饰变量、方法、代码块和嵌套类

常量：final static,在kotlin中使用const val(只能在object或者companion object或者类外使用)

synchronized：用于实现线程同步，确保多个线程对共享资源的访问是安全的

同步方法：方法在同一时刻只能被一个线程访问

同步代码块：代码块在同一时刻只能被一个线程访问

静态同步方法：静态方法锁定的是类的Class对象，确保同一时刻只有一个线程可以执行该类的静态同步方法

kotlin中同步方法只能使用@Synchronized

### 请简述一下String、StringBuffer和StringBuilder

||可变性|​线程安全|​性能|​适用场景|
|--|--|--|--|--|
|String|不可变的，每次创建新的String对象，原对象被丢弃|线程安全|性能较低|字符串内容不经常变化|
|StringBuffer|可变的,原有对象上进行修改|线程安全|由于同步机制，性能略低于StringBuilder|多线程环境下频繁修改字符串|
|StringBuilder|可变的|方法没有同步机制,线程不安全|性能最高|单线程环境下频繁修改字符串

### “equals”与“==”、“hashCode”的区别和使用场景

基本数据类型不能使用equals，==是比较值是否相等

默认情况下，引用类型使用equals和==效果相同，比较的是对象的内存地址

hashCode和equals作用类似，用来对比两个对象内容是否相等

- hashcode 相等，equals不一定相等
- equals 相等，hashcode一定相等
- hashcode 不相等，equals一定不相等

hashCode默认是基于对象内存地址，相等情况为哈希冲突时和内存地址重用时

重写hashCode是为了在HashMap,HashSet等基于哈希表实现的集合比较对象时可能误判

### Java中深拷贝与浅拷贝的区别
见[拷贝](../kotlin/kotlin_class.md#kotlin_copy)

### 谈谈Error和Exception的区别

Error和Exception都是Throwable类的子类，都可以被抛出(throw)和捕获(try catch)

Exception：表示程序运行中可以被预料到的异常情况，应该被捕获并进行相应的处理，分为两类

编译时异常：编译器强制要求处理，例如IOException，必须通过try-catch或throws声明

运行时异常：编译器不强制处理，通常由代码逻辑错误导致，例如NullPointerException

​Error：表示系统级的不可恢复错误，通常是JVM或系统资源引发的严重问题，程序无法通过代码进行处理或恢复。例如OutOfMemoryError、StackOverflowError，不应该被捕获或处理

### 谈谈你对Java泛型中类型擦除的理解，并说说其局限性

泛型类型参数（如 <T>）会被替换为边界类型（默认为 Object，或用户指定的上限类型，如 <T extends Number> 替换为 Number）。例如，List<String> 和 List<Integer> 在编译后都会变成 List，其 Class 对象相同（ArrayList.class）。

Java 1.5 引入泛型时，需要保证旧版本非泛型代码仍能运行，避免修改 JVM 底层机制

局限性

- 运行时类型信息丢失
- 无法创建泛型数组
- 无法实现基于泛型的重载
- 不安全，通过反射可以绕过泛型限制，向 List<Integer> 插入 String 对象

[泛型基本知识](../java/java_genericity.md)

### String为什么要设计成不可变的
安全性：由于字符串在程序中经常用于存储敏感信息（如数据库连接字符串、密码等），不可变性确保了这些信息在传递过程中不会被意外修改，从而提高了安全性。

​线程安全：不可变的字符串可以在多个线程之间安全地共享，而不需要额外的同步机制。这简化了并发编程，避免了数据竞争和不一致的问题。

​性能优化：不可变的字符串可以被缓存和重用。Java中的字符串池（String Pool）机制就是基于这一点，多个相同的字符串字面量可以共享同一个对象，从而节省内存空间。此外，不可变性还使得字符串的哈希值可以被缓存，提高了哈希表的查找效率。

​哈希表的使用：由于字符串是不可变的，它们可以作为字典的键（keys）或集合（sets）的元素。如果字符串是可变的，那么它们的哈希值可能会随着内容的改变而改变，导致无法正确地在哈希表中查找和比较。

​简化设计和实现：不可变性使得字符串的设计和实现更加简单和一致。开发人员不需要考虑字符串在多个地方被修改的情况，从而减少了潜在的错误

### 说说你对Java注解的理解

见[注解使用](../java/java_annotation.md)

### Java中使用多线程的方式有哪些

[启动线程的方式](../java/java_thread.md#thread_start)

### 说一下线程的几种状态

[线程状态](../java/java_thread.md#thread_life)

### 如何实现多线程中的同步
1. ​使用synchronized关键字
2. 使用ReentrantLock类
3. 使用volatile关键字
4. 使用原子类，如AtomicInteger、AtomicLong等
5. 使用Semaphore类
6. 使用CountDownLatch和CyclicBarrier

### 谈谈线程死锁，如何有效的避免线程死锁

指两个或多个线程在运行过程中，因争夺资源而造成的一种互相等待的现象

- ​固定加锁顺序：确保所有线程以相同的顺序获取锁，打破循环等待条件。
- ​使用超时机制：在获取锁时设置超时时间，超过时间后放弃获取锁并释放已持有的锁。
- ​避免嵌套锁：尽量避免在一个线程中同时获取多个锁，如果必须获取多个锁，确保按照固定的顺序获取。
- ​使用死锁检测工具：利用工具如 JProfiler、VisualVM 等检测和解决死锁问题。
- ​减少共享资源：尽量减少进程间共享资源的数量，或者采用副本而不是共享资源的方式

### 谈谈线程阻塞的原因

线程阻塞是指线程在运行过程中由于某些条件未满足而暂停执行的状态

原因

1. ​等待I/O操作：线程进行输入/输出操作（如读写文件、网络通信）时，如果操作不能立即完成，线程会被阻塞，直到I/O操作完成或发生错误。
2. ​同步等待：线程在访问共享资源（如同步代码块或方法）时，如果无法获得所需的锁，线程会被阻塞，直到获取到锁才能继续执行。
3. 睡眠等待：线程调用Thread.sleep(int n)方法后，会进入睡眠状态，暂停执行指定的时间，时间结束后线程恢复运行。
4. ​等待信号：线程调用对象的wait()方法后，会进入等待状态，直到其他线程调用该对象的notify()或notifyAll()方法将其唤醒。
5. ​等待连接：在网络编程中，线程在尝试与服务器建立连接（如调用Socket.connect()）时，如果连接未成功，线程会被阻塞，直到连接建立或发生异常。
6. ​读取数据：线程从输入流（如Socket的输入流）读取数据时，如果没有足够的数据，线程会被阻塞，直到读取到足够的数据或发生异常。
7. ​写入数据：线程向输出流（如Socket的输出流）写入数据时，如果输出缓冲区已满，线程会被阻塞，直到数据被完全写入或发生异常。
8. ​关闭连接：线程在关闭套接字（如调用Socket.close()）时，如果设置了延迟关闭，线程会被阻塞，直到所有数据发送完毕或超过延迟时间

### 请谈谈Thread中run()与start()的区别

run方法：不会创建线程，只是一个普通方法，可以被多次调用

start方法：jvm会创建线程，只能调用一次

### synchronized和volatile关键字的区别

见[synchronized vs volatile](../java/java_safe.md#synchronized_volatile)

### java线程中notify和notifyAll有什么区别
notify()：唤醒在此对象监视器上等待的单个线程。

如果有多个线程在对象监视器上等待，notify() 方法会随机一个线程唤醒，被唤醒的线程需要重新获取对象的锁，才能继续执行。

notifyAll()：唤醒在此对象监视器上等待的所有线程。
所有线程被唤醒后，它们都需要重新获取对象的锁，然后才能继续执行。
在竞争锁的过程中，只有一个线程能够获得锁并继续执行，其他线程将再次进入等待状态

### 什么是线程池？如何创建一个线程池？

见[线程池](../java/java_safe.md#thread_pool)

### 谈一谈java线程常见的几种锁？

[锁的分类](../java/java_lock.md#java_lock)

### 谈一谈线程sleep()和wait()的区别？

[sleep vs wait](../java/java_lock.md#sleep_wait)

### 谈谈ThreadLocal用法和原理
[ThreadLocal](../java/java_base.md#threadlocal)

### 谈一谈JAVA垃圾回收机制
- 新生代​：新创建的对象首先分配在新生代。分为Eden区和两个Survivor区（S0和S1）
- ​老年代​：经过多次垃圾回收后仍然存活的对象会被移动到老年代，一般存在于堆中
- ​永久代或​元空间​：用于存储类的元数据信息（在Java8及以后版本中，永久代被元空间取代，元空间使用本地内存），是方法区的实现

永久代是固定空间，元空间受限于系统可用内存

垃圾回收算法

- 标记-清除
- 复制
- 标记-整理
- 分代收集

垃圾回收器

- Serial垃圾回收器
- Parallel 垃圾回收器
- CMS垃圾回收器
- G1垃圾回收器
- ZGC和Shenandoah

Android主要使用ART GC，包括并发标记-清除（CMS）回收器和G1

### 什么是强、软、弱、虚引用以及它们之间的区别

强引用

​定义：强引用是最常见的引用类型，只要对象存在强引用，垃圾回收器就不会回收该对象。

​垃圾回收行为：即使内存不足，JVM也不会回收具有强引用的对象，而是抛出OutOfMemoryError异常。

​使用场景：适用于大多数普通对象的引用，如成员变量、局部变量等。

软引用

​定义：软引用通过SoftReference类实现，用于描述一些还有用但非必须的对象。

​垃圾回收行为：在内存不足时，垃圾回收器会回收软引用指向的对象。内存充足时，软引用对象不会被回收。

​使用场景：适用于实现内存敏感的缓存，如图片缓存、数据缓存等。

弱引用

​定义：弱引用通过WeakReference类实现，比软引用更弱。

​垃圾回收行为：无论内存是否充足，只要垃圾回收器运行，弱引用指向的对象就会被回收。

​使用场景：适用于解决内存泄漏问题，如WeakHashMap中的键，或者用于监听器的管理。

虚引用

​定义：虚引用通过PhantomReference类实现，是最弱的一种引用类型。

​垃圾回收行为：虚引用无法通过get()方法获取对象实例，对象被回收时，虚引用会被加入到关联的引用队列中。

​使用场景：主要用于跟踪对象被垃圾回收的活动，执行一些清理操作，如释放资源、记录日志等

### JVM、Dalvik、ART三者的原理和区别

JVM

​定义与作用：JVM是Java虚拟机的缩写，它是Java平台的核心组件，负责执行Java字节码文件（.class文件）。JVM为Java程序提供了一个独立于底层硬件和操作系统的运行环境，实现了“一次编写，到处运行”的跨平台特性。

​主要功能：JVM的主要功能包括字节码编译、内存管理和垃圾回收。它使用即时编译（JIT）技术将字节码转换为本地机器码，以提高运行时性能。

Dalvik虚拟机

​定义与作用：Dalvik虚拟机是Android操作系统中的一种虚拟机技术，专门用于执行Android应用程序的字节码（.dex文件）。它针对移动设备的资源限制进行了优化，具有较低的内存占用和高效的电池使用。

​工作原理：Dalvik虚拟机基于寄存器架构，使用.dex文件格式存储和执行应用程序代码。它在运行时依赖即时编译器（JIT）将部分字节码实时编译为本地机器码，以提高执行效率。

Dalvik虚拟机仅支持32位架构

ART

​定义与作用：ART是Android 5.0（Lollipop）及更高版本中的默认运行时环境，取代了Dalvik虚拟机。ART通过预先编译（AOT）技术将字节码编译为本地机器码，进一步提高了应用的启动速度和运行效率。

​工作原理：ART在应用安装时就预先将字节码编译为机器码，改进了内存分配和垃圾回收机制，提供了更好的内存管理。

在Android 8.0之前，ART会将dex文件优化并编译成odex文件，odex文件包含了经过AOT编译后的代码以及dex的完整内容

从Android 8.0开始，odex文件中的dex内容被移动到了.vdex文件中，而odex文件则主要包含编译后的代码，引入.xdex用于支持64位架构

ART还会生成.art文件，用于加速运行时加载odex中热点代码的速度，包含了类信息和odex中热点方法的索引

ART使用dex2oat工具将dex文件编译成.oat文件，这是一个ELF格式的可执行文件，包含了预编译后的机器码

三者的区别

- ​编译方式：JVM使用即时编译（JIT）技术，而Dalvik虚拟机也使用JIT，但ART使用预先编译（AOT）技术。
​性能：由于ART使用AOT编译，其性能通常优于使用JIT编译的Dalvik虚拟机。
- ​内存管理：ART提供了更高效的内存管理机制，特别是在处理大型应用程序时。
- ​安装时间：由于AOT编译，ART的应用程序安装时间可能比Dalvik更长。
- ​兼容性：Dalvik虚拟机与旧的应用程序兼容性更好，而ART可能存在一些兼容性问题，特别是在旧版本的Android系统中

### java/kotlin中的单例

见[设计模式](../design/design_single.md)

### Kotlin中的数据类型有隐式转换吗
没有，需要显示转化，如
```kotlin
val byteNum: Byte = 13
val intNum: Int = byteNum.toInt() // 正确
```

java中有，如float a = 1;

### 说说Kotlin中的Any与Java中的Object有何异同

在Java中，Object是所有引用类的超类，是类层级的根。

在Kotlin中，Any是所有非空类型的超类，也是类层级的根

Any只提供了toString()、equals()和hashCode()方法

### Kotlin中集合遍历有哪几种方式
for循环遍历、forEach高阶函数、map映射、​filter过滤、​flatMap扁平化映射、迭代器遍历、惰性计算(asSequence)、并发遍历(parallelStream)

### Kotlin内置标准函数let的原理是什么？
```kotlin
inline <T,R> fun T.let(block:(T)-> R):R {
    return block(this)
}
```
### Kotlin语言的run高阶函数的原理是什么？
```kotlin
inline <R> fun T.let(block:T.()-> R):R {
    return block()
}
```

### 请谈谈Kotlin中的Coroutines，它与线程有什么区别？有哪些优点

协程与线程的区别

​资源消耗：

​线程：每个线程通常占用约1MB的内存空间，创建和销毁线程的开销较大，尤其是在高并发场景下容易导致内存溢出（OOM）。

​协程：协程是轻量级的，内存占用远小于线程，可以在单个线程中创建成千上万个协程，极大地减少了内存消耗。
​调度机制：

​线程：线程的调度由操作系统负责，属于抢占式调度，线程之间的同步和通信较为复杂，需要使用锁、信号量等机制。
​协程：协程的调度由编程语言或框架自行管理，Kotlin协程通过挂起函数实现非抢占式的协作调度，协程间的通信和数据传递更加便捷。
​编程模型：

​线程：多线程编程通常以共享状态和锁为基础，编写并发代码较为复杂，容易引发死锁和竞态条件。
​协程：协程提供了一种结构化并发编程的方式，通过挂起函数的调用实现代码的暂停和恢复，使得异步编程更易于理解和维护